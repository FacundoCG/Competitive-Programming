Problema:

Dado un array de longitud n quiero encontrar la subsecuencia más larga de este tal que sea creciente para todo elemento de ella.

Está claro que la longitud de la subsecuencia más larga desde la posición 1 hasta la i queda determinada por:

mls(0, i) = { 1                                 si i = 1
            { max(mls(0, i-1), 1 + mls(0, f(i)) si no 

Voy a usar un algoritmo que dado un i, me diga el elemento en la posición j < i más cercano tal que: A[i] <= A[j]. Necesito diseñar esto de forma inteligente tal que no sea muy costo.

- Si i = 0: P[0] = -1 porque no tiene ningún elemento que cumpla la propiedad
- Si i = 1: P[1] = if A[1] <= A[0] then 0 else -1

- Para un i generico:

A[i-1] <= A[P[i-1]] and A[i] > A[i-1]

int longest_increasing_subsequence(vector<int>& A, vector<int>& memo, vector<int>& P, int i){
    if (i == 0){
        return 1;
    }

    if (memo[i] == INT_MIN){
        memo[i] = max(longest_increasing_subsequence(A, memo, P, i-1), longest_increasing_subsequence(A, memo, P, P[i]));
    }

    return memo[i];
}







int definingThing(vector<int>& P, vector<int>& A, int i, int j){
    if (i == -1){
        return -1;
    }

    if (A[j] <= A[i]){
        return i;
    }

    return definingThing(P, P[i], j);
}




P[0] = -1;
for (int i = 1; i < n; i++){
    if (A[i] <= A[i-1]){
        P[i] = i-1;
    } else {
        P[i] = definingThing(P, A, P[i-1], i);
    }
}

3 1 2



P[i] = if A[i] <= A[i-1] then i-1 else (if A[i] <= A[P[i-1]] then P[i-1] else (if A[i]))

A = [1, 2, 3 , 4]
P = [-1, -1, -1, -1]

A = [10, 1, 2, 4, 3]
P = [-1, 0, 0, 0, 3]


memo[0] = 0;

for (int i = 1; i < n; i++){
    memo[i] = memo[i-1];

    if (P[i] != -1){
        memo[i] = max(memo[i], memo[P[i]]);
    }
}


























